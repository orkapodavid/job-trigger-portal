
# Reflex Database Best Practices and Coding Standards with SQLModel

This document outlines the best practices and coding standards for using databases in Reflex applications with SQLModel. Reflex uses SQLModel to provide a built-in ORM wrapping SQLAlchemy, combining the power of SQLAlchemy with the simplicity of Pydantic. Following these guidelines will help you write maintainable, efficient, and secure Reflex applications.

## 1. Code Organization and Structure

### 1.1 Directory Structure

A well-organized directory structure improves code readability and maintainability. Here's a recommended structure for Reflex projects with SQLModel:


project_name/
 ├── project_name/
 │   ├── __init__.py
 │   ├── project_name.py    # Main Reflex app file
 │   ├── models/
 │   │   ├── __init__.py
 │   │   ├── user.py        # User model using rx.Model
 │   │   ├── product.py     # Product model using rx.Model
 │   │   └── ...
 │   ├── pages/
 │   │   ├── __init__.py
 │   │   ├── index.py       # Home page
 │   │   ├── user_page.py   # User management page
 │   │   └── ...
 │   ├── components/
 │   │   ├── __init__.py
 │   │   ├── forms.py       # Reusable form components
 │   │   └── ...
 │   └── state.py           # Reflex state management
 ├── alembic/               # Database migrations
 │   ├── versions/
 │   │   ├── ... (migration scripts)
 │   ├── alembic.ini
 │   └── env.py
 ├── assets/                # Static assets
 ├── .web/                  # Generated web files (auto-created)
 ├── rxconfig.py            # Reflex configuration
 ├── requirements.txt
 └── README.md


### 1.2 File Naming Conventions

*   **Models:** Use descriptive names for model files (e.g., `user.py`, `product.py`) - these inherit from `rx.Model`.
*   **Pages:** Use descriptive names for page files (e.g., `user_page.py`, `dashboard.py`).
*   **Components:** Use descriptive names for reusable components (e.g., `forms.py`, `tables.py`).
*   **State:** Use `state.py` for Reflex state management classes.
*   **Configuration:** Use `rxconfig.py` for Reflex app configuration including database URLs.
*   **Migrations:** Alembic manages migration script names automatically via `reflex db` commands.

### 1.3 Module Organization

*   **Models:** Group related models into separate modules, each inheriting from `rx.Model`.
*   **Pages:** Organize pages by functionality (e.g., user management, product catalog).
*   **Components:** Create reusable UI components that can interact with database models.
*   **State:** Organize state classes by functionality, integrating database operations.

### 1.4 Component Architecture

*   **Model Layer:** Define database models using `rx.Model` (SQLModel) for type-safe database interactions.
*   **State Layer:** Implement business logic in Reflex state classes that handle database operations using `rx.session()`.
*   **Component Layer:** Create reusable UI components that interact with state to display and manipulate data.
*   **Page Layer:** Compose components into complete pages with routing and navigation.

### 1.5 Code Splitting

*   **Model Definition:** Split large models into smaller, manageable classes.
*   **Query Logic:** Move complex query logic into reusable functions or methods.
*   **Configuration:** Externalize configuration settings using environment variables.

## 2. Common Patterns and Anti-patterns

### 2.1 Design Patterns

*   **State Pattern (Reflex-specific):** Centralize database operations within Reflex state classes for better organization:

    ```python
    import reflex as rx
    from sqlmodel import select
    from .models import User

    class UserState(rx.State):
        users: list[User] = []
        
        def load_users(self):
            with rx.session() as session:
                statement = select(User)
                self.users = session.exec(statement).all()
                
        def get_user_by_id(self, user_id: int) -> User | None:
            with rx.session() as session:
                return session.get(User, user_id)
    ```
    
*   **Model-State-Component Pattern:** Separate concerns between data models (`rx.Model`), state management (`rx.State`), and UI components.
*   **Reactive Data Flow:** Use Reflex's reactive system to automatically update UI when database state changes.

### 2.2 Recommended Approaches

*   **rx.Model:** Use `rx.Model` (SQLModel) to define database models with automatic Pydantic validation:
    ```python
    import reflex as rx
    from sqlmodel import Field
    
    class User(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
        email: str
        age: int | None = None
    ```
*   **rx.session():** Use `rx.session()` context manager for database operations:
    ```python
    with rx.session() as session:
        user = session.get(User, user_id)
        session.add(new_user)
        session.commit()
    ```
*   **Type Safety:** Leverage SQLModel's type annotations for better IDE support and runtime validation.
*   **Eager Loading:** Use SQLAlchemy's loading strategies with `.options()` to optimize queries.
*   **Reflex DB Commands:** Use `reflex db init`, `reflex db makemigrations`, and `reflex db migrate` for schema management.

### 2.3 Anti-patterns and Code Smells

*   **Direct SQLAlchemy Usage:** Avoid bypassing rx.Model; use SQLModel patterns for consistency and type safety.
*   **Long-Lived Sessions:** Don't store `rx.session()` in state variables; always use context managers.
*   **State Mutations Outside Methods:** Perform database operations only within state methods, not in components directly.
*   **Ignoring Type Hints:** Always use proper type annotations with SQLModel for better validation and IDE support.
*   **N+1 Query Problem:** Use relationship loading strategies to avoid inefficient queries:
    ```python
    # Good: Load with relationships
    with rx.session() as session:
        statement = select(User).options(selectinload(User.posts))
        users = session.exec(statement).all()
    ```

### 2.4 State Management

*   **Reflex State Integration:** Integrate database operations with Reflex state management:
    ```python
    class ProductState(rx.State):
        products: list[Product] = []
        loading: bool = False
        
        def load_products(self):
            self.loading = True
            with rx.session() as session:
                statement = select(Product)
                self.products = session.exec(statement).all()
            self.loading = False
    ```
*   **Session Lifecycle:** Always use `rx.session()` as a context manager for automatic cleanup.
*   **State Reactivity:** Leverage Reflex's reactive system to update UI automatically when state changes.

### 2.5 Error Handling

*   **State-Level Error Handling:** Handle database errors within state methods:
    ```python
    class UserState(rx.State):
        error_message: str = ""
        
        def create_user(self, user_data: dict):
            try:
                with rx.session() as session:
                    user = User(**user_data)
                    session.add(user)
                    session.commit()
                    self.error_message = ""
            except Exception as e:
                self.error_message = f"Error creating user: {str(e)}"
    ```
*   **Validation Errors:** Leverage SQLModel's Pydantic validation for automatic input validation.
*   **User Feedback:** Display error messages in the UI through state variables.

## 3. Performance Considerations

### 3.1 Optimization Techniques

*   **Indexing:** Add indexes to frequently queried columns in your `rx.Model` definitions:
    ```python
    class User(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        email: str = Field(index=True)  # Add index for frequent queries
        username: str = Field(index=True)
    ```
*   **Query Optimization:** Use SQLModel's select patterns with proper filtering:
    ```python
    # Efficient query with filtering
    with rx.session() as session:
        statement = select(User).where(User.active == True).limit(10)
        users = session.exec(statement).all()
    ```
*   **Connection Pooling:** Configure in `rxconfig.py`:
    ```python
    # rxconfig.py
    import reflex as rx
    
    config = rx.Config(
        app_name="myapp",
        db_url="postgresql://user:password@localhost/dbname?pool_size=20&max_overflow=30"
    )
    ```
*   **State-Level Caching:** Cache frequently accessed data in Reflex state:
    ```python
    class AppState(rx.State):
        _user_cache: dict[int, User] = {}
        
        def get_cached_user(self, user_id: int) -> User | None:
            if user_id not in self._user_cache:
                with rx.session() as session:
                    user = session.get(User, user_id)
                    if user:
                        self._user_cache[user_id] = user
            return self._user_cache.get(user_id)
    ```

### 3.2 Memory Management

*   **Session Management:** Always use `rx.session()` context manager to ensure proper cleanup:
    ```python
    # Good: Context manager ensures cleanup
    with rx.session() as session:
        users = session.exec(select(User)).all()
    
    # Bad: Manual session management
    session = rx.session()
    users = session.exec(select(User)).all()
    session.close()  # Easy to forget!
    ```
*   **Result Set Size:** Limit query results to prevent memory issues:
    ```python
    # Paginated results
    with rx.session() as session:
        statement = select(User).offset(page * page_size).limit(page_size)
        users = session.exec(statement).all()
    ```
*   **State Memory Management:** Clear large data from state when no longer needed:
    ```python
    class DataState(rx.State):
        large_dataset: list[dict] = []
        
        def clear_data(self):
            self.large_dataset = []  # Free memory
    ```

### 3.3 Relationship Loading Strategies

*   **Joined Loading**: Load related entities efficiently in Reflex:
    ```python
    from sqlmodel import select
    from sqlalchemy.orm import joinedload
    
    class BlogState(rx.State):
        posts_with_authors: list[Post] = []
        
        def load_posts_with_authors(self):
            with rx.session() as session:
                statement = select(Post).options(joinedload(Post.author))
                self.posts_with_authors = session.exec(statement).all()
    ```
*   **Selectin Loading**: Efficient for collections in Reflex state:
    ```python
    from sqlalchemy.orm import selectinload
    
    def load_users_with_posts(self):
        with rx.session() as session:
            statement = select(User).options(selectinload(User.posts))
            self.users = session.exec(statement).all()
    ```
*   **Lazy Loading Control**: Set loading behavior on relationships:
    ```python
    class User(rx.Model, table=True):
        posts: list["Post"] = Relationship(
            back_populates="author",
            sa_relationship_kwargs={"lazy": "selectin"}  # Always use selectin loading
        )
    ```

## 4. Security Best Practices

### 4.1 Common Vulnerabilities

*   **SQL Injection:** SQLModel and Reflex prevent SQL injection through parameterized queries:
    ```python
    # Safe: SQLModel automatically parameterizes
    with rx.session() as session:
        statement = select(User).where(User.email == user_email)
        user = session.exec(statement).first()
    
    # Never do this (vulnerable to injection):
    # raw_query = f"SELECT * FROM users WHERE email = '{user_email}'"
    ```
*   **Data Exposure:** Protect sensitive fields in Reflex models:
    ```python
    class User(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        email: str
        password_hash: str = Field(exclude=True)  # Exclude from serialization
        
        def dict(self, **kwargs) -> dict:
            # Custom serialization excluding sensitive data
            d = super().dict(**kwargs)
            d.pop('password_hash', None)
            return d
    ```

### 4.2 Input Validation

*   **SQLModel Validation:** Leverage built-in Pydantic validation in Reflex models:
    ```python
    from pydantic import validator, EmailStr
    
    class User(rx.Model, table=True):
        email: EmailStr  # Automatic email validation
        age: int = Field(ge=0, le=150)  # Age constraints
        
        @validator('email')
        def validate_email_domain(cls, v):
            if not v.endswith('@company.com'):
                raise ValueError('Must use company email')
            return v
    ```
*   **State-Level Validation:** Validate in state methods before database operations:
    ```python
    class UserState(rx.State):
        def create_user(self, form_data: dict):
            try:
                # SQLModel validation happens automatically
                user = User(**form_data)
                with rx.session() as session:
                    session.add(user)
                    session.commit()
            except ValidationError as e:
                self.error_message = str(e)
    ```

### 4.3 Authentication and Authorization

*   **State-Based Auth:** Implement authentication in Reflex state:
    ```python
    import bcrypt
    
    class AuthState(rx.State):
        current_user: User | None = None
        is_authenticated: bool = False
        
        def login(self, email: str, password: str):
            with rx.session() as session:
                statement = select(User).where(User.email == email)
                user = session.exec(statement).first()
                
                if user and bcrypt.checkpw(password.encode(), user.password_hash):
                    self.current_user = user
                    self.is_authenticated = True
                    return rx.redirect("/dashboard")
                else:
                    return rx.window_alert("Invalid credentials")
    ```
*   **Protected Routes:** Use state to protect pages:
    ```python
    def protected_page() -> rx.Component:
        return rx.cond(
            AuthState.is_authenticated,
            dashboard_content(),
            rx.redirect("/login")
        )
    ```

### 4.4 Data Protection

*   **Password Hashing:** Hash passwords before storing:
    ```python
    import bcrypt
    
    class User(rx.Model, table=True):
        email: str
        password_hash: str = Field(exclude=True)
        
        @classmethod
        def create_with_password(cls, email: str, password: str):
            password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
            return cls(email=email, password_hash=password_hash.decode())
    ```
*   **Environment Variables:** Store sensitive config in environment variables:
    ```python
    # rxconfig.py
    import os
    import reflex as rx
    
    config = rx.Config(
        app_name="myapp",
        db_url=os.getenv("DATABASE_URL", "sqlite:///reflex.db")
    )
    ```
*   **Field-Level Encryption:** For highly sensitive data:
    ```python
    from cryptography.fernet import Fernet
    
    class SensitiveData(rx.Model, table=True):
        id: int | None = Field(primary_key=True)
        encrypted_data: str
        
        def set_data(self, data: str, key: bytes):
            f = Fernet(key)
            self.encrypted_data = f.encrypt(data.encode()).decode()
    ```

### 4.5 Secure Configuration

*   **Database URLs:** Use secure connection strings in production:
    ```python
    # rxconfig.py
    config = rx.Config(
        app_name="myapp",
        db_url="postgresql+psycopg2://user:pass@host:5432/db?sslmode=require"
    )
    ```
*   **HTTPS Enforcement:** Configure for production deployment
*   **Environment-Specific Settings:** Different configs for dev/staging/prod

## 5. Testing Approaches

### 5.1 Unit Testing

*   **Model Testing:** Test SQLModel models with Pydantic validation:
    ```python
    import pytest
    from pydantic import ValidationError
    from myapp.models import User
    
    def test_user_creation():
        user = User(name="John", email="john@example.com", age=30)
        assert user.name == "John"
        assert user.email == "john@example.com"
    
    def test_user_validation():
        with pytest.raises(ValidationError):
            User(name="John", email="invalid-email", age=-5)
    ```
*   **State Testing:** Test Reflex state methods:
    ```python
    def test_user_state_load_users(mocker):
        # Mock rx.session
        mock_session = mocker.patch('reflex.session')
        mock_session.return_value.__enter__.return_value.exec.return_value.all.return_value = []
        
        state = UserState()
        state.load_users()
        
        assert state.users == []
    ```

### 5.2 Integration Testing

*   **Database Integration:** Test with a test database:
    ```python
    import pytest
    import reflex as rx
    from sqlmodel import create_engine, Session
    from myapp.models import User
    
    @pytest.fixture
    def test_session():
        engine = create_engine("sqlite:///:memory:")
        rx.Model.metadata.create_all(engine)
        with Session(engine) as session:
            yield session
    
    def test_user_crud(test_session):
        # Create
        user = User(name="Test User", email="test@example.com")
        test_session.add(user)
        test_session.commit()
        
        # Read
        retrieved_user = test_session.get(User, user.id)
        assert retrieved_user.name == "Test User"
    ```
*   **Component Integration:** Test components with mock state:
    ```python
    def test_user_list_component():
        mock_state = UserState()
        mock_state.users = [User(name="John", email="john@test.com")]
        
        component = user_list_component(mock_state)
        # Test component rendering with state
    ```

### 5.3 End-to-End Testing

*   **Full Application Testing:** Test complete user workflows:
    ```python
    import pytest
    from playwright.sync_api import Page
    
    def test_user_registration_flow(page: Page):
        # Navigate to registration page
        page.goto("http://localhost:3000/register")
        
        # Fill form
        page.fill("[name=email]", "test@example.com")
        page.fill("[name=password]", "password123")
        page.click("button[type=submit]")
        
        # Verify redirect to dashboard
        page.wait_for_url("**/dashboard")
        assert "Welcome" in page.inner_text("h1")
    ```
*   **State Persistence Testing:** Verify data persists across page refreshes and state changes.

### 5.4 Test Organization

*   **Test Directory Structure:** Organize tests parallel to source structure:
    ```
    project_name/
    ├── project_name/
    │   ├── models/
    │   ├── pages/
    │   └── state.py
    └── tests/
        ├── test_models/
        ├── test_pages/
        ├── test_state.py
        └── conftest.py
    ```
*   **Fixtures:** Create reusable test fixtures:
    ```python
    # conftest.py
    import pytest
    import reflex as rx
    from sqlmodel import create_engine, Session
    
    @pytest.fixture
    def test_engine():
        return create_engine("sqlite:///:memory:")
    
    @pytest.fixture
    def test_session(test_engine):
        rx.Model.metadata.create_all(test_engine)
        with Session(test_engine) as session:
            yield session
    ```

### 5.5 Mocking and Stubbing

*   **Mocking rx.session()**: Mock database sessions for unit tests:
    ```python
    import pytest
    from unittest.mock import patch, MagicMock
    
    @patch('reflex.session')
    def test_state_method(mock_session):
        # Setup mock
        mock_session.return_value.__enter__ = MagicMock()
        mock_session.return_value.__exit__ = MagicMock()
        
        # Test state method
        state = UserState()
        state.load_users()
        
        # Verify session was used
        mock_session.assert_called_once()
    ```
*   **Component Mocking**: Mock dependencies in components:
    ```python
    def test_component_with_mocked_state():
        with patch('myapp.state.UserState') as mock_state:
            mock_state.users = []
            component = my_component()
            # Test component behavior
    ```

## 6. Common Pitfalls and Gotchas

### 6.1 Frequent Mistakes

*   **Forgetting to Commit:** Always commit changes in `rx.session()`:
    ```python
    # Good: Explicit commit
    with rx.session() as session:
        session.add(user)
        session.commit()  # Don't forget this!
    
    # Bad: Changes not persisted
    with rx.session() as session:
        session.add(user)  # Missing commit
    ```
*   **Relationship Configuration:** Use proper SQLModel relationship syntax:
    ```python
    # Good: Proper bidirectional relationship
    class User(rx.Model, table=True):
        posts: list["Post"] = Relationship(back_populates="author")
    
    class Post(rx.Model, table=True):
        author_id: int = Field(foreign_key="user.id")
        author: User = Relationship(back_populates="posts")
    ```
*   **State Mutation Patterns:** Mutate state correctly in Reflex:
    ```python
    # Good: Direct assignment triggers reactivity
    def update_users(self):
        with rx.session() as session:
            self.users = session.exec(select(User)).all()
    
    # Bad: In-place modification doesn't trigger updates
    def bad_update_users(self):
        with rx.session() as session:
            self.users.extend(session.exec(select(User)).all())
    ```

### 6.2 Edge Cases

*   **State Synchronization:** Handle concurrent state updates carefully:
    ```python
    class UserState(rx.State):
        users: list[User] = []
        loading: bool = False
        
        def refresh_users(self):
            if self.loading:  # Prevent concurrent refreshes
                return
            
            self.loading = True
            with rx.session() as session:
                self.users = session.exec(select(User)).all()
            self.loading = False
    ```
*   **Model Inheritance:** Be careful with SQLModel table inheritance:
    ```python
    # Good: Use abstract base for shared fields
    class BaseModel(rx.Model):
        id: int | None = Field(default=None, primary_key=True)
        created_at: datetime = Field(default_factory=datetime.utcnow)
    
    class User(BaseModel, table=True):
        name: str
        email: str
    ```
*   **Large State Objects:** Avoid storing large datasets directly in state:
    ```python
    # Bad: Large list in state
    class BadState(rx.State):
        all_records: list[dict] = []  # Could be millions of records
    
    # Good: Paginated approach
    class GoodState(rx.State):
        current_page_records: list[dict] = []
        current_page: int = 1
        total_pages: int = 0
    ```

### 6.3 Version-Specific Issues

*   **Reflex Updates:** Keep Reflex and SQLModel versions compatible:
    ```python
    # requirements.txt
    reflex>=0.4.0
    sqlmodel>=0.0.8
    ```
*   **SQLAlchemy Version:** Reflex uses SQLAlchemy 1.4 patterns, be aware of differences from 2.0
*   **Database Driver Compatibility:** Ensure database drivers work with your SQLModel version

### 6.4 Debugging Strategies

*   **Query Logging:** Enable SQL query logging in development:
    ```python
    # rxconfig.py - Development config
    import reflex as rx
    
    config = rx.Config(
        app_name="myapp",
        db_url="sqlite:///dev.db?echo=true"  # Enable SQL logging
    )
    ```
*   **State Debugging:** Use browser dev tools to inspect Reflex state:
    ```python
    # Add debug info to state
    class DebugState(rx.State):
        debug_info: dict = {}
        
        def debug_query(self, query_name: str):
            self.debug_info[query_name] = {
                "timestamp": datetime.now().isoformat(),
                "user_count": len(self.users)
            }
    ```
*   **Database Inspection:** Use database clients or Reflex admin tools to inspect data

## 7. Tooling and Environment

### 7.1 Recommended Development Tools

*   **IDE:** VS Code with Python and Reflex extensions, or PyCharm
*   **Database Client:** pgAdmin, Dbeaver, or TablePlus for database inspection
*   **Reflex CLI:** Built-in commands for database management:
    ```bash
    reflex db init          # Initialize database migrations
    reflex db makemigrations # Create migration scripts
    reflex db migrate       # Apply migrations
    reflex run             # Start development server
    ```

### 7.2 Build Configuration

*   **rxconfig.py:** Central configuration for Reflex apps:
    ```python
    import reflex as rx
    import os
    
    config = rx.Config(
        app_name="myapp",
        db_url=os.getenv("DATABASE_URL", "sqlite:///reflex.db"),
        env=rx.Env.DEV,  # or rx.Env.PROD
    )
    ```
*   **Requirements:** Include necessary database dependencies:
    ```txt
    reflex>=0.4.0
    sqlmodel>=0.0.8
    psycopg2-binary  # For PostgreSQL
    pymysql          # For MySQL
    ```
*   **Environment Variables:** Use `.env` files for local development:
    ```bash
    DATABASE_URL=postgresql://user:pass@localhost:5432/mydb
    SECRET_KEY=your-secret-key
    ```

### 7.3 Development Workflow

*   **Hot Reloading:** Reflex automatically reloads on code changes
*   **Database Migrations:** Version control your schema changes:
    ```bash
    # Make changes to models
    reflex db makemigrations --message "Add user table"
    # Review generated migration in alembic/versions/
    reflex db migrate
    ```
*   **Code Quality:** Use formatters and linters:
    ```bash
    pip install black isort flake8
    black .
    isort .
    flake8 .
    ```

### 7.4 Deployment Best Practices

*   **Production Database:** Configure production database in `rxconfig.py`:
    ```python
    config = rx.Config(
        app_name="myapp",
        db_url=os.getenv("DATABASE_URL"),  # From environment
        env=rx.Env.PROD
    )
    ```
*   **Database Migrations:** Apply migrations in deployment pipeline:
    ```bash
    reflex db migrate
    reflex export --frontend-only  # For static deployment
    ```
*   **Environment Variables:** Set production database URL and secrets

### 7.5 Monitoring and Maintenance

*   **Database Monitoring:** Monitor query performance and connection pool usage
*   **State Performance:** Track large state objects and memory usage
*   **Migration Management:** Keep track of applied migrations across environments
*   **Backup Strategy:** Implement regular database backups for production

## 8. Reflex-Specific Database Relationships

### 8.1 Defining Relationships

*   **One-to-Many Relationships:** Use SQLModel's Relationship with proper foreign keys:
    ```python
    from sqlmodel import Relationship, Field
    
    class User(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        name: str
        email: str
        
        # One-to-many: User has many posts
        posts: list["Post"] = Relationship(back_populates="author")
    
    class Post(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        title: str
        content: str
        author_id: int = Field(foreign_key="user.id")
        
        # Many-to-one: Post belongs to one user
        author: User = Relationship(back_populates="posts")
    ```

*   **Many-to-Many Relationships:** Use association tables:
    ```python
    class UserPostLink(rx.Model, table=True):
        user_id: int = Field(foreign_key="user.id", primary_key=True)
        post_id: int = Field(foreign_key="post.id", primary_key=True)
    
    class User(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        liked_posts: list["Post"] = Relationship(
            back_populates="liked_by",
            link_model=UserPostLink
        )
    
    class Post(rx.Model, table=True):
        id: int | None = Field(default=None, primary_key=True)
        liked_by: list[User] = Relationship(
            back_populates="liked_posts",
            link_model=UserPostLink
        )
    ```

### 8.2 Querying Relationships in Reflex State

*   **Loading Related Data:** Use eager loading in state methods:
    ```python
    from sqlalchemy.orm import selectinload, joinedload
    
    class BlogState(rx.State):
        users_with_posts: list[User] = []
        
        def load_users_with_posts(self):
            with rx.session() as session:
                statement = select(User).options(selectinload(User.posts))
                self.users_with_posts = session.exec(statement).all()
        
        def load_posts_with_authors(self):
            with rx.session() as session:
                statement = select(Post).options(joinedload(Post.author))
                self.posts_with_authors = session.exec(statement).all()
    ```

*   **Creating Related Objects:** Handle relationships in state:
    ```python
    class BlogState(rx.State):
        def create_post_with_author(self, author_id: int, post_data: dict):
            with rx.session() as session:
                # Get the author
                author = session.get(User, author_id)
                if not author:
                    self.error = "Author not found"
                    return
                
                # Create post with relationship
                post = Post(**post_data, author_id=author_id)
                session.add(post)
                session.commit()
                
                # Refresh data
                self.load_posts_with_authors()
    ```

### 8.3 Relationship Loading Strategies

*   **Configure Default Loading:** Set loading behavior on relationships:
    ```python
    class User(rx.Model, table=True):
        posts: list["Post"] = Relationship(
            back_populates="author",
            sa_relationship_kwargs={"lazy": "selectin"}  # Always eager load
        )
    ```

*   **Query-Specific Loading:** Override loading per query:
    ```python
    def load_with_custom_loading(self):
        with rx.session() as session:
            # Use different loading strategies as needed
            statement = select(User).options(
                selectinload(User.posts).selectinload(Post.comments)
            )
            self.users = session.exec(statement).all()
    ```

By adhering to these best practices, you can build robust, scalable, and maintainable Reflex applications with SQLModel. The combination of Reflex's reactive state management, SQLModel's type safety, and SQLAlchemy's powerful ORM capabilities provides an excellent foundation for data-driven web applications. Remember to adapt these guidelines to your specific project requirements and always leverage the strengths of the Reflex ecosystem.
    