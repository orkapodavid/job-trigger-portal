---
description: FastAPI patterns for building backend APIs to complement Reflex full-stack applications
globs: api/**/*.py, backend/**/*.py
---

# You are an expert in Python and FastAPI for backend API development.

## Context

This guide covers FastAPI patterns for **backend-only APIs** that complement Reflex full-stack applications. For full-stack development, refer to reflex-framework-base.mdc. For database operations, see sqlalchemy.mdc. For authentication, see reflex-azure-auth.mdc.

## When to Use FastAPI with Reflex

- **Microservices Architecture:** Separate API services from Reflex frontend
- **Third-Party Integrations:** External API endpoints for webhooks, integrations
- **Performance-Critical APIs:** High-throughput endpoints separate from main app
- **Legacy API Support:** Maintain existing FastAPI endpoints alongside Reflex

## Key Principles

- Write concise, technical responses with accurate Python examples
- Use functional, declarative programming for route handlers
- Use descriptive variable names with auxiliary verbs (e.g., `is_active`, `has_permission`)
- Use lowercase with underscores for files (e.g., `api/user_routes.py`)
- Return typed responses for API consistency

## Project Structure for FastAPI Backend APIs

### Standalone API Structure
✅ **Backend API alongside Reflex:**
```
project/
├── reflex_app/              # Main Reflex application
│   ├── pages/
│   ├── components/
│   ├── state.py
│   └── models.py            # Shared data models (rx.Model)
├── api/                     # Separate FastAPI backend
│   ├── routers/
│   │   ├── webhooks.py      # Webhook endpoints
│   │   ├── integrations.py  # Third-party integrations
│   │   └── external.py      # External API routes
│   ├── schemas.py           # API-specific Pydantic schemas
│   ├── dependencies.py      # FastAPI dependencies
│   ├── main.py              # FastAPI app instance
│   └── config.py            # API configuration
├── shared/                  # Shared utilities
│   ├── models.py            # Shared data models
│   └── utils.py
├── tests/
├── rxconfig.py              # Reflex configuration
└── requirements.txt
```

### Organization Principles
- Keep FastAPI routes separate from Reflex pages
- Share data models between Reflex and FastAPI when needed
- Use `api/` directory for backend-only endpoints
- Reflex handles main application; FastAPI handles specialized APIs

## Async Best Practices

### Route Function Selection
✅ **Use `async def` for I/O-bound operations:**
```python
@router.post("/webhooks/shopify")
async def shopify_webhook(payload: dict, background_tasks: BackgroundTasks):
    background_tasks.add_task(process_order, payload)
    return {"status": "received"}
```

✅ **Use `def` for CPU-bound operations:**
```python
@router.post("/process/image")
def process_image(file: UploadFile):
    return perform_image_analysis(file)
```

### Background Tasks
- Use `BackgroundTasks` for webhook processing
- Offload to task queues (Celery, RQ) for long-running jobs

## Pydantic Schemas for API Contracts

### API Request/Response Models
✅ **Define API-specific schemas:**
```python
from pydantic import BaseModel, Field

class WebhookPayload(BaseModel):
    event_type: str
    data: dict
    timestamp: datetime
    signature: str = Field(..., description="Webhook signature for verification")

class APIResponse(BaseModel):
    success: bool
    message: str
    data: dict | None = None
```

### Validation Best Practices
- Use `@field_validator` for complex validation
- Share schemas with Reflex via `shared/` directory when needed

## Dependency Injection

### Common Patterns for Backend APIs
✅ **API Key validation dependency:**
```python
from fastapi import Header, HTTPException

async def verify_api_key(x_api_key: str = Header(...)):
    if x_api_key not in settings.valid_api_keys:
        raise HTTPException(status_code=401, detail="Invalid API key")
    return x_api_key

@router.post("/external/data")
async def receive_data(data: dict, api_key: str = Depends(verify_api_key)):
    return {"status": "received"}
```

✅ **Webhook signature verification:**
```python
import hmac, hashlib

async def verify_webhook_signature(
    payload: bytes = Body(...),
    signature: str = Header(..., alias="X-Webhook-Signature")
):
    expected = hmac.new(settings.webhook_secret.encode(), payload, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(signature, expected):
        raise HTTPException(status_code=401, detail="Invalid signature")
    return payload
```

## API Design for Backend Endpoints

### Webhook and Integration Endpoints
✅ **Design webhook receivers:**
```python
@router.post("/webhooks/github", status_code=status.HTTP_200_OK)
async def github_webhook(
    payload: WebhookPayload,
    signature: str = Depends(verify_webhook_signature)
):
    """Handle GitHub repository events (push, PR, issues)."""
    await process_github_event(payload)
    return {"status": "received"}

@router.post("/webhooks/twilio", status_code=status.HTTP_200_OK)
async def twilio_webhook(payload: TwilioPayload):
    """Handle incoming SMS/call notifications from Twilio."""
    await process_twilio_message(payload)
    return {"status": "received"}

@router.post("/webhooks/sendgrid", status_code=status.HTTP_200_OK)
async def sendgrid_webhook(events: list[SendGridEvent]):
    """Process SendGrid email events (delivered, opened, clicked)."""
    await process_email_events(events)
    return {"status": "processed"}
```

### External API Endpoints
✅ **Expose data to external services:**
```python
@router.get("/external/stats", response_model=StatsResponse)
async def get_stats(api_key: str = Depends(verify_api_key)):
    return await calculate_stats()

@router.post("/external/sync", status_code=status.HTTP_202_ACCEPTED)
async def sync_data(data: SyncRequest, api_key: str = Depends(verify_api_key)):
    return {"status": "accepted", "job_id": "..."}
```

### HTTP Status Codes
- `200 OK`: Successful webhook receipt
- `202 Accepted`: Async processing started
- `401 Unauthorized`: Invalid API key/signature
- `422 Unprocessable Entity`: Invalid payload

## Error Handling

### API-Specific Exception Handlers
✅ **Handle webhook and integration errors:**
```python
from fastapi import Request
from fastapi.responses import JSONResponse
import logging

logger = logging.getLogger(__name__)

class WebhookValidationError(Exception):
    pass

@app.exception_handler(WebhookValidationError)
async def webhook_validation_handler(request: Request, exc: WebhookValidationError):
    logger.warning(f"Webhook validation failed: {exc}")
    return JSONResponse(
        status_code=401,
        content={"error": "invalid_signature", "message": str(exc)}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception in API: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"error": "internal_error", "message": "API error occurred"}
    )
```

## Database Access

### Using Reflex Models in FastAPI
✅ **Share database models between Reflex and FastAPI:**
```python
# In shared/models.py or reflex_app/models.py
import reflex as rx
from sqlmodel import Field

class WebhookLog(rx.Model, table=True):
    """Log all incoming webhook events for audit trail."""
    id: int | None = Field(default=None, primary_key=True)
    source: str  # e.g., 'github', 'shopify', 'twilio'
    event_type: str  # e.g., 'push', 'order.created', 'sms.received'
    payload: dict
    received_at: datetime
    processed: bool = False
    error_message: str | None = None

# In api/routers/webhooks.py
import reflex as rx
from shared.models import WebhookLog

@router.post("/webhooks/discord")
async def discord_webhook(payload: DiscordWebhook, background_tasks: BackgroundTasks):
    """Receive Discord bot events and log them."""
    with rx.session() as session:
        log_entry = WebhookLog(
            source="discord",
            event_type=payload.event_type,
            payload=payload.dict(),
            received_at=datetime.now()
        )
        session.add(log_entry)
        session.commit()
    
    background_tasks.add_task(process_discord_event, payload)
    return {"status": "queued"}
```

**Note:** For database operations, prefer using `rx.session()` to maintain consistency with Reflex. See sqlalchemy.mdc for detailed database patterns.

## Security for Backend APIs

### API Key Authentication
✅ **Secure external endpoints:**
```python
from fastapi import Security, HTTPException
from fastapi.security import APIKeyHeader

api_key_header = APIKeyHeader(name="X-API-Key")

async def verify_api_key(api_key: str = Security(api_key_header)):
    if api_key not in settings.valid_api_keys:
        raise HTTPException(status_code=401, detail="Invalid API key")
    return api_key
```

### Webhook Security
✅ **Verify webhook signatures:**
```python
import hmac, hashlib
from fastapi import Header, HTTPException, Request

# GitHub webhook verification
async def verify_github_signature(
    request: Request,
    signature: str = Header(..., alias="X-Hub-Signature-256")
):
    """Verify GitHub webhook signature using SHA256."""
    payload = await request.body()
    expected = "sha256=" + hmac.new(
        settings.github_webhook_secret.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()
    
    if not hmac.compare_digest(signature, expected):
        raise HTTPException(status_code=401, detail="Invalid signature")
    return payload

# Shopify webhook verification
async def verify_shopify_signature(
    request: Request,
    signature: str = Header(..., alias="X-Shopify-Hmac-SHA256")
):
    """Verify Shopify webhook using base64 encoded HMAC."""
    import base64
    payload = await request.body()
    expected = base64.b64encode(
        hmac.new(
            settings.shopify_webhook_secret.encode(),
            payload,
            hashlib.sha256
        ).digest()
    ).decode()
    
    if not hmac.compare_digest(signature, expected):
        raise HTTPException(status_code=401, detail="Invalid signature")
    return payload
```

### CORS Configuration
✅ **Allow specific origins:**
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],  # Your Reflex app
    allow_credentials=True,
    allow_methods=["POST"],
    allow_headers=["X-API-Key", "Content-Type"],
)
```

**Note:** For user authentication in Reflex apps, use reflex-azure-auth. See reflex-azure-auth.mdc.

## Performance for Backend APIs

### Rate Limiting
✅ **Protect API endpoints:**
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@router.post("/webhooks/public")
@limiter.limit("10/minute")
async def public_webhook(request: Request, payload: dict):
    return {"status": "received"}
```

### Background Processing
✅ **Offload heavy operations:**
```python
from fastapi import BackgroundTasks

@router.post("/process/large-file")
async def process_file(file: UploadFile, background_tasks: BackgroundTasks):
    background_tasks.add_task(process_large_file, file)
    return {"status": "queued", "job_id": "..."}
```

## Testing Backend APIs

### Test Client Setup
✅ **Use async test client:**
```python
import pytest
from httpx import AsyncClient
from api.main import app

@pytest.fixture
async def client():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
```

### Test Organization
✅ **Test API endpoints:**
```python
@pytest.mark.asyncio
async def test_webhook_endpoint(client: AsyncClient):
    response = await client.post(
        "/webhooks/test",
        json={"event_type": "test", "data": {}},
        headers={"X-Webhook-Signature": "valid_signature"}
    )
    assert response.status_code == 200
    assert response.json()["status"] == "received"
```

## Code Quality

### Linting and Formatting
- Use `ruff` for linting and formatting
- Configure pre-commit hooks for consistency

### Type Hints
✅ **Use type annotations:**
```python
async def process_webhook(
    payload: WebhookPayload,
    background_tasks: BackgroundTasks
) -> dict[str, str]:
    background_tasks.add_task(log_event, payload)
    return {"status": "processing"}
```

## Documentation

### API Documentation
✅ **Enhance OpenAPI docs:**
```python
@router.post(
    "/webhooks/slack",
    status_code=status.HTTP_200_OK,
    summary="Receive Slack interactive events",
    description="Handle Slack slash commands, buttons, and interactive messages",
    responses={
        200: {"description": "Event processed successfully"},
        401: {"description": "Invalid verification token"},
        422: {"description": "Invalid event payload"},
    }
)
async def slack_webhook(payload: SlackEventPayload):
    """Process Slack workspace events with token verification."""
    if payload.token != settings.slack_verification_token:
        raise HTTPException(status_code=401, detail="Invalid token")
    return await process_slack_event(payload)
```

## Deployment

### Running FastAPI Alongside Reflex
✅ **Separate deployment:**
```bash
# Terminal 1: Run Reflex app
reflex run

# Terminal 2: Run FastAPI backend
uvicorn api.main:app --host 0.0.0.0 --port 8001
```

### Docker Configuration
✅ **Multi-container setup:**
```yaml
# docker-compose.yml
version: '3.8'
services:
  reflex-app:
    build: .
    command: reflex run --env prod
    ports:
      - "3000:3000"
  
  fastapi-backend:
    build: ./api
    command: uvicorn main:app --host 0.0.0.0 --port 8000
    ports:
      - "8001:8000"
```

### Environment Variables
- Keep API secrets separate from Reflex app config
- Use different `.env` files or prefixes for FastAPI
- Validate required variables on startup

## Best Practices Summary

1. **Use FastAPI for specialized backend APIs** - Webhooks, integrations, external endpoints
2. **Share models with Reflex** - Use `rx.Model` for consistency
3. **Secure all endpoints** - API keys, webhook signatures, rate limiting
4. **Use background tasks** - Process webhooks asynchronously
5. **Comprehensive error handling** - Log errors, return meaningful responses
6. **Type everything** - Full type annotations for better IDE support
7. **Test thoroughly** - Unit and integration tests for all endpoints
8. **Monitor and log** - Track API usage, errors, and performance

For full-stack Reflex development, see reflex_framework_rules.mdc.
For database operations, see sqlalchemy.mdc.
For authentication, see reflex-azure-auth.mdc. 